#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <iostream>
#include <errno.h>
#include <dirent.h>
#include <stdlib.h>

using namespace std;

string findAndReplace(string &s, string toReplace, string replaceWith) {
  while (s.find(toReplace) != string::npos) {
    s = s.replace(s.find(toReplace), toReplace.length(), replaceWith);
  }
  return s;
}

int getdir(string dir, vector<string> &files) {
  DIR *dp;
  struct dirent *dirp;

  if ((dp = opendir(dir.c_str())) == NULL) {
    cout << "Error(" << errno << ") opening " << dir << endl;
    return errno;
  }

  while ((dirp = readdir(dp)) != NULL) {
    files.push_back(string(dirp->d_name));
  }

  closedir(dp);
  return 0;
}

bool hasEnding(string const &fullString, string const &ending) {
  if (fullString.length() >= ending.length()) {
    return (0 == fullString.compare(fullString.length() - ending.length(), ending.length(), ending));
  }
  else {
    return false;
  }
}

vector<string> pruneVecImg(const vector<string> &inVec) {
  vector<string> inVec_new;
  for (int f = 0; f < inVec.size(); ++f) {
    if (hasEnding(inVec[f], "jpg")) {
      inVec_new.push_back(inVec[f]);
    }
    else if (hasEnding(inVec[f], "jpeg")) {
      inVec_new.push_back(inVec[f]);
    }
    else if (hasEnding(inVec[f], "png")) {
      inVec_new.push_back(inVec[f]);
    }
  }
  return inVec_new;
}

vector<string> pruneVec(const vector<string> &inVec, string contain) {
  vector<string> inVec_new;
  for (int f = 0; f < inVec.size(); ++f) {
    if (inVec[f].find(contain) == string::npos) {
      inVec_new.push_back(inVec[f]);
    }
  }
  return inVec_new;
}

string formatXMLWide(string tag, auto inside, string tabs="") {
  stringstream ss;
  if (tag.find(" ") != string::npos) {
    stringstream nss(tag);
    string realtag;
    nss >> realtag;
    ss << tabs << "<" << tag << ">\n" << inside << "\n" << tabs << "</" << realtag << ">\n";
  }
  else {
    ss << tabs << "<" << tag << ">\n" << inside << "\n" << tabs << "</" << tag << ">\n";
  }
  return ss.str();
}

string formatXMLNarrow(string tag, auto inside, string tabs="") {
  stringstream ss;
  if (tag.find(" ") != string::npos) {
    stringstream nss(tag);
    string realtag;
    nss >> realtag;
    ss << tabs << "<" << tag << ">" << inside << "</" << realtag << ">\n";
  }
  else {
    ss << tabs << "<" << tag << ">" << inside << "</" << tag << ">\n";
  }
  return ss.str();
}

string comment(auto inside) {
  stringstream ss;
  ss << "<!-- " << inside << " -->\n";
  return ss.str();
}

int main(int argc, char* argv[]) {
  string mypath;
  if (argc > 1)
    mypath = string(argv[1]);
  else
    mypath = string(".");

  vector<string> onlyfiles;
  getdir(mypath, onlyfiles);
  vector<string> imagefiles = pruneVecImg(onlyfiles);

  char resolvedpath[100];
  realpath(mypath.c_str(), resolvedpath);
  mypath = resolvedpath;

  cout << "Enter durration in minutes for each wallpaper, enter 0 for 24 hour total rotation time" << endl;
  cout << "> ";

  int input;

  cin >> input;

  double duration;
  if (input == 0) {
    duration = (24*60*60-imagefiles.size()*0.5)/(double)imagefiles.size();
  } else {
    duration = input * 60;
  }
  int tempdur = duration*10;
  duration = tempdur/10.0;

  string innertext = "";
  for (int i = 0; i < imagefiles.size(); ++i) {
    innertext += formatXMLWide(
        "static", formatXMLNarrow(
          "duration", duration, "\t\t") + formatXMLNarrow(
          "file", mypath+"/"+imagefiles[i], "\t\t")
        , "\t");
    if (i+1 < imagefiles.size())
      innertext += formatXMLWide(
          "transition type=\"overlay\"", formatXMLNarrow(
            "duration", "0.5", "\t\t") + formatXMLNarrow(
            "from", mypath+"/"+imagefiles[i], "\t\t") + formatXMLNarrow(
            "to", mypath+"/"+imagefiles[i+1], "\t\t")
          , "\t");
    else
      innertext += formatXMLWide(
          "transition type=\"overlay\"", formatXMLNarrow(
            "duration", "0.5", "\t\t") + formatXMLNarrow(
            "from", mypath+"/"+imagefiles[i], "\t\t") + formatXMLNarrow(
            "to",   mypath+"/"+imagefiles[0], "\t\t")
          , "\t");
  }

  string outtext = comment("File generated by Riley Trautman") + formatXMLWide(
      "background", formatXMLWide(
        "starttime", formatXMLNarrow(
          "hour",   "0",  "\t\t") + formatXMLNarrow(
          "minute", "0",  "\t\t") + formatXMLNarrow(
          "second", "01", "\t\t")
        , "\t") + comment("Starts at midnight") + innertext);

  outtext = findAndReplace(outtext, "\n\n", "\n");

  ofstream output("output.xml");
  output << outtext;
  output.close();
}
